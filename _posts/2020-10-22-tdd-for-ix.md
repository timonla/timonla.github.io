---
layout: post
title: "Advanced Scripting for Beijer iX Developer with TDD workflow"
subtitle: "Setting up a test driven development environment in Visual Studio to develop Beijer iX software"
date: 2021-04-21
permalink: "/blog/tdd-for-ix/"
thumbnail: "/assets/img/blog/thumbnails/tdd-for-ix.png"
hidden: true
---

When I started writing `C#` code for an embedded system using the
.NET Compact Framework 3.5 (.NET CF), in particular during the development of
[iX software](https://www.beijerelectronics.com/en/Products/Operator___panels/iX___Software)
for a [Beijer HMI panel](https://www.beijerelectronics.com/en/Products/Operator___panels),
I had quite some trouble finding a good testing setup.

For the development of iX software, Beijer provides an IDE, called iX Developer.
Unsurprisingly, iX Developer felt like quite the downgrade from the Visual Studio (VS) world
I was coming from, for all non UI related parts of the implementation.
I also had no idea how to properly test my business logic without VS.
So I sat down and tried to figure out a setup that would allow me to follow a test driven development (TDD)
workflow in VS and still end up with code that would compile properly in iX Developer,
since the IDE is used to load the software onto the panel later.
I am quite happy with the setup this blog post is documenting and hope it avoids some
pitfalls for you, if you enter a similar journey.

My experience with this setup is specific to Beijer iX Developer.
However, parts of this post could be helpful for similar platforms with .NET CF as well.
This is by no means the ultimate guide to either working with iX and VS or for TDD.
Hence, I am happy for any suggestions on how to improve the setup.

The example project, which I reference in this blog post, is available in this [GitHub repository](https://github.com/timonla/border-patrol).

### Advantages of Visual Studio over iX Developer

While the preferred development methodology for any pair of two software projects
might look quite different, it is difficult to deny the advantages of being
able to test an implementation reliably.
The importance of testability only increases in the context of embedded and potentially
safety critical software.
For writing business logic, the [VS test explorer](https://docs.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer?view=vs-2019)
alone should be motivation enough to look into a possible setup using VS.

For building the UI and wiring up the `tags` one should still use iX Developer.
This is where it shines.
In fact, the setup documented in this blog post requires some interaction
with iX Developer, even for the business logic parts.
However, after an initial effort to define which `tags` the business
logic uses to communicate with the UI, it only needs to be opened from time to time.

On top of the test explorer, VS comes with a few more treats, such as:
* A great debugger
* Swift navigation to definitions and references
* Interactive error and warning messages
* Extension support, such as [VsVim](https://marketplace.visualstudio.com/items?itemName=JaredParMSFT.VsVim)
* Automatic formatting
* Refactoring functionality (even more with access to [ReSharper](https://www.jetbrains.com/resharper/))
* Dark mode ðŸŒš and other editor themes 

There is a good chance that you are eligible for the free [community version](https://visualstudio.microsoft.com/vs/community/),
which has all the functionality you need, or you are already paying for VS already.

### Test driven development approach

I will not go into detail about this approach in this blog post but for those new to it,
the basic concept goes something like this:

* Write failing tests first, specifying the expected behavior of the implementation
* Only after that, write the code that is needed to pass the test cases
* As soon as all test cases pass, start to refactor the code

To add more requirements, simply add new test cases and repeat the steps above.
The pattern is called:
<span style="color: Salmon">Red</span> â†’
<span style="color: DarkOliveGreen">Green</span> â†’
<span style="color:CornflowerBlue">Refactor</span>.
With this approach one is less likely to implement any unneeded functionality
and does not have to be afraid of refactoring the implementation.
As long as all test cases are all green, nothing can break.
It's also a very rewarding process since one is constantly returning to a state where
everything is working fine and it is easy to backtrack to it.
On top of that, where a test case is failing, there is always input data for that scenario,
to debug it with.
Of course in the beginning everything will go a bit slower.

Robert C. Martin gives an excellent introduction to and motivation for TDD in
[this presentation](https://www.youtube.com/watch?v=qkblc5WRn-U).
For a shorter example check out this [YouTube Video](https://youtu.be/Y5XIjXcWaK8)

I wrote a [blog post](https://timon.la/blog/bdd-nunit-test-naming/) on a proper naming scheme
for `NUnit` test cases.
The `border-patrol` example follows the same conventions.

### Setup a Visual Studio project for compact framework development

The biggest pitfall when developing for iX in VS and then compiling
it in iX Developer is to not setup the VS project correctly and ending up using features 
and libraries that are not available for .NET CF.
Officially, support for .NET CF development ends with VS 2008 but there is
a way to configure the project for later versions as well.
I followed [this setup guide](https://gist.github.com/skarllot/4953ddb6e23d8a6f0816029c4155997a)
to configure my project in VS 2019 without any problems.
Apparently the download of Power Toys, linked in that post, is not available anymore.
[Web archive](https://web.archive.org/web/*/https://download.microsoft.com/download/f/a/c/fac1342d-044d-4d88-ae97-d278ef697064/NETCFv35PowerToys.msi)
to the rescue. ðŸ¦¸

### How to structure the project

There are a few caveats when it comes to creating and structuring the script
files.
First of all, new script files must be created in iX Developer, as there are two files
that will be created alongside the `[script name].Script.cs` file.
Once the script files are created, I recommend to close iX Developer immediately, to
reduce the risk of accidentally making changes and overriding the progress from VS.
Jut open it again to make changes to the `tags` or the UI.

<!-- ```
â”Œâ”€â”€ I think I
â”œâ”€â”€ am going to use
â”‚   â””â”€â”€ this to describe
â””â”€â”€ the
    â”œâ”€â”€ project
    â””â”€â”€ structure.
``` -->

#### What goes into which file?

* What is going on with internal classes in iX developer and what is generated automatically as partial classes for script files?
* Internal classes and test objects
* How to choose namespace names and class names.
* Don't name classes like files.
* Don't name classes like namespaces either.

### How to handle tags

`Tags` are the interface between the UI and the business logic.
To access the `tags` from the business logic, there are two basic approaches.

1. Implement the entire business logic stateless (functional) and build a wrapper around
it that will feed it with `tag` values and update `tags` with the return values.
2. Create a stupid wrapper, that wraps the `tags` in `VariableReferences` so that the
business logic can update them directly.

#### VariableReference

I created the class `VariableReference` that has a `Get` and `Set` method to
which I can then map the respective functions of the `tags`.


```cs
internal class VariableReference<T> {
	public Func<T> Get { get; private set; }
	public Action<T> Set { get; private set; }

	public VariableReference(Func<T> getter, Action<T> setter) {
		Get = getter;
		Set = setter;
	}
}
```

Using this class one can then create a class containing all the tags needed in
the business logic.

```cs
internal class MyBusinessLogicTags {
	public readonly VariableReference<string> SomeTagName;
	public readonly VariableReference<bool> SomeOtherTagName;

	public MyBusinessLogicTagNames(
		VariableReference<string> someTagName = null,
		VariableReference<bool> someOtherTagName = null
	) {
		SomeTagName = someTagName;
		SomeOtherTagName = someOtherTagName;
	}
}
```

#### Instantiate

In the generated script module, which has access to the `tags`, I instantiate
a tag container that maps the read and write operations on the `tags` to the
`VariableReferences`. Here are some examples:

```cs
public partial class MyModule {
	static MyBusinessLogicTags myTags = new MyBusinessLogicTags(
		new VariableReference<string>(
			() => Globals.Tags.SomeTagName.Value,
			val => { Globals.Tags.SomeTagName.Value = val; }),
		new VariableReference<bool>(
			() => Globals.Tags.SomeOtherTagName.Value,
			val => { Globals.Tags.SomeOtherTagName.SetTag(); })
	);
}
```

This tag container is then passed as a parameter to the constructor of the
business logic module. 

#### Helper functions for testing

During testing, this helper class can be used to instantiate a tag container
that can be setup before each test case to simulate the desired state.

```cs
class Helpers {
	class TagContainer {
		public string someTagName;
		public bool someOtherTagName;

		public TagContainer() {
			someTagName = "";
			someOtherTagName = false;
		}
	}

	public static MyBusinessLogicTags CreateTags() {
		var tagContainer = new TagContainer();

		return new MyBusinessLogicTags(
			someTagName: new VariableReference<string>(
				() => tagContainer.someTagName,
				val => { tagContainer.someTagName = val; }),
			someOtherTagName: new VariableReference<string>(
				() => tagContainer.someOtherTagName,
				val => { tagContainer.someOtherTagName = val; })
		);
	}
}
```

### Limitations of Beijer iX over .NET CF

Even after setting the project up as described above, there are a few particularities
to avoid altogether or at least be aware of when opening iX Developer again.
Some of these will break the build in iX Developer, even though the project builds fine
in VS.

#### Auto properties

[Auto properties](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties)
in iX Developer only work as long as both `get` and `set` are specified.
In practice one might want to use just `{ get; }` to create a `readonly` property
but iX Developer won't compile that.

```cs
class Rectangle {
	public int A { get; set; }
	public int B { get; }
}
```

#### Named parameters

When using [named parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments),
iX Developer will complain about them but build the project just fine. ðŸ¤·

```cs
class Square: Rectangle {
	public Square(int a) : base(a = a, b = a) { }
}
```

#### Expression-bodied members

I noticed that iX Developer won't compile with
[expression-based members](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members#read-only-properties)
like this one:

```cs
class Rectangle {
	public int A;
	public int B;
	public int Area => A * B;
}
```
