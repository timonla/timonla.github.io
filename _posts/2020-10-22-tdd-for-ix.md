---
layout: post
title: "Advanced Scripting for Beijer iX Developer (and how to not loose your Object Oriented Mind)"
subtitle: "My take on setting up a test driven development environment in Visual Studio for Beijer iX software"
date: 2020-10-22
permalink: "/blog/tdd-for-ix/"
thumbnail: "/assets/img/blog/thumbnails/tdd-for-ix.png"
hidden: true
---

I recently gained my first experience writing `C#` code for an embedded system using the .NET Compact Framework 3.5 (.NET CF),
in particular the development of [iX software](https://www.beijerelectronics.com/en/Products/Operator___panels/iX___Software)
for a [Beijer HMI panel](https://www.beijerelectronics.com/en/Products/Operator___panels).
For the development of iX software, Beijer provides an IDE, called iX Developer.
Unsurprisingly, iX Developer felt like quite the downgrade, for all non UI parts of the implementation, compared to
Visual Studio (VS), which I was used to.
I also had no idea how to properly test my business logic without it.
So I sat down and tried to figure out a setup that would allow me to follow a test driven development (TDD)
workflow in VS and still end up with code that would compile properly in iX Developer,
since the IDE is used to load the software onto the panel later.
It took a while to find a good setup and along the way I uncovered quite a few pitfalls.
Hence, I decided to document my approach here, so that it can be a resource to you, if you are attempting something similar.
Or you can point out what I am still missing, because this is by no means the ultimate or only way to do TDD
for .NET CF in VS, it's merely what worked well for me so far.

My experience with this setup is specific to Beijer iX Developer.
However, parts of this post could be helpful for similar platforms with .NET CF as well.

### Advantages of Visual Studio over iX Developer

While the preferred development methodology might look different for any two software
projects, it would be difficult to deny the advantages of being able to test an 
implementation.
Testability only gains in importance in the context of embedded and potentially safety 
critical software.
Since my role in the project was purely writing business logic,
the [VS test explorer](https://docs.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer?view=vs-2019)
alone was motivation enough to look into a possible setup using VS.
It would definitely not be as relevant if you were only wiring up the UI components
with different `tags`.
That's what iX Developer is for.
In fact even the setup that I present in this post will require some interaction
with iX Developer.
However, if you make an effort to define early, through which tags your business
logic will effectively communicate with the UI, you only have to open it from time
to time later on.

On top of the test explorer, VS comes with a few more treats, such as:
* A great debugger
* Swift navigation to definitions and references
* Interactive error and warning messages
* Extension support, such as [VsVim](https://marketplace.visualstudio.com/items?itemName=JaredParMSFT.VsVim)
* Automatic formatting
* Refactoring functionality (even more if you have access to [ReSharper](https://www.jetbrains.com/resharper/))
* Dark mode ðŸŒš and other editor themes 

The community version free to use and provides all the functionality you need.

### Test driven development approach

I am really happy that I was able to find a setup that allowed me to follow
a TDD approach for this project.
I won't go into detail about this approach in this post but if you are new to it,
the basic concept is easy to summarize.
You write failing tests first, specifying the expected behavior of your implementation.
Only after that you write the code that is needed to pass these test cases.
As soon as all your test cases pass you can start to refactor your code.
You can add more requirements by adding new test cases and repeating this loop.
The pattern is called:
<span style="color: Salmon">Red</span> â†’
<span style="color: DarkOliveGreen">Green</span> â†’
<span style="color:CornflowerBlue">Refactor</span>.
I like this approach because you only end up implementing what you are going to need 
and don't have to be afraid to refactor your code.
As long as you keep running your tests from time to time and they are all green,
you cannot break anything.
It's also a very rewarding process since you are constantly returning to a state where
everything is working fine and you can easily backtrack back to it.
And if something does not work out, you already have the test case at hand to debug
your implementation with.
Of course in the beginning everything will go a bit slower.

Robert C. Martin gives an excellent introduction to and motivation for TDD in
[this presentation](https://www.youtube.com/watch?v=qkblc5WRn-U).
For a shorter example check out this [YouTube Video](https://youtu.be/Y5XIjXcWaK8)

### Setup your Visual Studio project for compact framework development

The biggest pitfall when developing your code for iX project in VS and then compiling
it in iX Developer is to not setup your VS project correctly and end up using features 
and libraries that are not available for .NET CF.
Officially support for .NET CF development ends with Visual Studio 2008 but there is
a way to configure your project for later versions as well.
I followed [this setup guide](https://gist.github.com/skarllot/4953ddb6e23d8a6f0816029c4155997a)
to configure my project in VS 2019 without any problems.
Apparently the download of Power Toys, linked in that post, is not available anymore.
You can [use the web archive](https://web.archive.org/web/*/https://download.microsoft.com/download/f/a/c/fac1342d-044d-4d88-ae97-d278ef697064/NETCFv35PowerToys.msi)
to access it anyways.

### How to structure your project

There are a few caveats when it comes to creating and structuring the script
files.
First of all, new script files must be created in iX Developer, as there are two files
that will be created alongside the `MyScriptName.Script.cs` file.
As soon as you created the file it is recommended to close iX immediately so
that you do not accidentally make changes and override the process from VS.
Open it again if you need to make changes to the tags or the UI.

```
â”Œâ”€â”€ I think I
â”œâ”€â”€ am going to use
â”‚   â””â”€â”€ this to describe
â””â”€â”€ the
    â”œâ”€â”€ project
    â””â”€â”€ structure.
```

#### What goes into which file?

* What is going on with internal classes in iX developer and what is generated automatically as partial classes for script files?
* Internal classes and test objects
* How to choose namespace names and class names.
* Don't name your classes like you name your files.
* Don't name your classes like you name your namespaces either.

### How to handle tags

Tags are the interface between the UI parts and your business logic.
The logic that you implement needs to be connected to the tags that you can use in the UI elements in some way.
One solution is to work fully stateless and apply the effects of your logic in
the generated module that has access to the tags.
The option I went for is to create a `VariableReference` structure and pass
those to the business logic to write to it directly.
This has the advantage that I can easily test the effects of different methods
on each other and can even simulate an entire sequence of function calls.

#### VariableReference

I created the class `VariableReference` that has a `Get` and `Set` method to
which I can then map the respective functions of the tags.


```cs
internal class VariableReference<T> {
	public Func<T> Get { get; private set; }
	public Action<T> Set { get; private set; }

	public VariableReference(Func<T> getter, Action<T> setter) {
		Get = getter;
		Set = setter;
	}
}
```

Using this class one can then create a class containing all the tags needed in
the business logic.

```cs
internal class MyBusinessLogicTags {
	public readonly VariableReference<string> SomeTagName;
	public readonly VariableReference<bool> SomeOtherTagName;

	public MyBusinessLogicTagNames(
		VariableReference<string> someTagName = null,
		VariableReference<bool> someOtherTagName = null
	) {
		SomeTagName = someTagName;
		SomeOtherTagName = someOtherTagName;
	}
}
```

#### Instantiate

In the generated script module, which has access to the tags, I will instantiate
a tag container that maps the read and write operations on the tags to the
`VariableReferences`. Here are some examples:

```cs
public partial class MyModule {
	static MyBusinessLogicTags myTags = new MyBusinessLogicTags(
		new VariableReference<string>(
			() => Globals.Tags.SomeTagName.Value,
			val => { Globals.Tags.SomeTagName.Value = val; }),
		new VariableReference<bool>(
			() => Globals.Tags.SomeOtherTagName.Value,
			val => { Globals.Tags.SomeOtherTagName.SetTag(); })
	);
}
```

This tag container is then passed as a parameter to the constructor of my
business logic module.

#### Helper functions for testing

For testing purposes you should create something similar.

```cs
class Helpers {
	class TagContainer {
		public string someTagName;
		public bool someOtherTagName;

		public TagContainer() {
			someTagName = "";
			someOtherTagName = false;
		}
	}

	public static MyBusinessLogicTags CreateTags() {
		var tagContainer = new TagContainer();

		return new MyBusinessLogicTags(
			someTagName: new VariableReference<string>(
				() => tagContainer.someTagName,
				val => { tagContainer.someTagName = val; }),
			someOtherTagName: new VariableReference<string>(
				() => tagContainer.someOtherTagName,
				val => { tagContainer.someOtherTagName = val; })
		);
	}
}
```

### Limitations of Beijer iX over .NET CF

Even after setting your project up as described above, there are a few particularities
to avoid altogether or at least be aware of once you open iX Developer again.
Some of these will break the build in iX Developer, even though your project builds fine
in VS.

#### Auto properties

You can use [auto properties](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties)
in iX Developer as long as you always specify both `get` and `set`.
In practice you might want to use just `{ get; }` to create a `readonly` property
but iX Developer won't compile that.

```cs
class Rectangle {
	public int A { get; set; }
	public int B { get; }
}
```

#### Named parameters

If you uses [named parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments),
iX Developer will build your project fine but complain about them.

```cs
class Square: Rectangle {
	public Square(int a) : base(a = a, b = a) { }
}
```

#### Expression-bodied members

I noticed that iX Developer won't compile if you include
[expression-based members](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members#read-only-properties)
like this one.

```cs
class Rectangle {
	public int A;
	public int B;
	public int Area => A * B;
}
```
